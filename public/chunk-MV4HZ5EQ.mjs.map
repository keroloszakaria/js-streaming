{"version":3,"sources":["../src/core/backoff.ts","../src/core/Stream.ts","../src/adapters/websocket.ts","../src/adapters/sse.ts","../src/adapters/http.ts","../src/adapters/longPolling.ts","../src/adapters/hls.ts","../src/adapters/webrtc.ts","../src/index.ts"],"sourcesContent":["export function createBackoff(opts?: {\r\n  baseMs?: number;\r\n  maxMs?: number;\r\n  factor?: number;\r\n  jitter?: boolean;\r\n}) {\r\n  const base = opts?.baseMs ?? 500;\r\n  const max = opts?.maxMs ?? 15000;\r\n  const factor = opts?.factor ?? 2;\r\n  const jitter = opts?.jitter ?? true;\r\n  let attempt = 0;\r\n\r\n  return {\r\n    reset() {\r\n      attempt = 0;\r\n    },\r\n    next() {\r\n      const exp = Math.min(max, base * Math.pow(factor, attempt++));\r\n      return jitter ? Math.random() * exp : exp;\r\n    },\r\n  };\r\n}\r\n","import {\r\n  BaseOptions,\r\n  ListenerMap,\r\n  StreamAdapter,\r\n  StreamAPI,\r\n  StreamState,\r\n  StreamStatus,\r\n} from \"./types\";\r\nimport { createBackoff } from \"./backoff\";\r\n\r\nexport class StreamCore implements StreamAPI {\r\n  private _state: StreamState = {\r\n    status: \"idle\",\r\n    error: null,\r\n    messages: [],\r\n    isOpen: false,\r\n  };\r\n  private listeners: ListenerMap = {\r\n    open: [],\r\n    close: [],\r\n    error: [],\r\n    message: [],\r\n    status: [],\r\n  };\r\n  private adapter: StreamAdapter | null = null;\r\n  private opts: BaseOptions;\r\n  private retrying = false;\r\n  private retries = 0;\r\n  private backoff = createBackoff();\r\n\r\n  constructor(adapter: StreamAdapter, opts: BaseOptions) {\r\n    this.adapter = adapter;\r\n    this.opts = {\r\n      bufferLimit: 500,\r\n      autoReconnect: true,\r\n      maxRetries: 10,\r\n      ...opts,\r\n    };\r\n    if (opts.backoff) this.backoff = createBackoff(opts.backoff);\r\n  }\r\n\r\n  get state() {\r\n    return this._state;\r\n  }\r\n\r\n  private setStatus(s: StreamStatus) {\r\n    this._state.status = s;\r\n    this._state.isOpen = s === \"open\";\r\n    this.emit(\"status\", s);\r\n  }\r\n\r\n  private setError(e: Error) {\r\n    this._state.error = e;\r\n    this.setStatus(\"error\");\r\n    this.emit(\"error\", e);\r\n  }\r\n\r\n  private pushMessage(m: unknown) {\r\n    const limit = this.opts.bufferLimit!;\r\n    const arr = this._state.messages;\r\n    arr.push(m);\r\n    if (arr.length > limit) arr.splice(0, arr.length - limit);\r\n    this.emit(\"message\", m);\r\n  }\r\n\r\n  // hooks adapters will call:\r\n  public _onOpen = () => {\r\n    this.retries = 0;\r\n    this.backoff.reset();\r\n    this.setStatus(\"open\");\r\n    this.emit(\"open\");\r\n  };\r\n  public _onClose = () => {\r\n    this.setStatus(\"closed\");\r\n    this.emit(\"close\");\r\n    if (\r\n      this.opts.autoReconnect &&\r\n      this.retries < (this.opts.maxRetries ?? 10)\r\n    ) {\r\n      this.retrying = true;\r\n      const delay = this.backoff.next();\r\n      setTimeout(() => this.open(), delay);\r\n    }\r\n  };\r\n  public _onError = (e: Error) => this.setError(e);\r\n  public _onMessage = (m: unknown) => this.pushMessage(m);\r\n\r\n  async open(): Promise<void> {\r\n    if (!this.adapter) return;\r\n    this.setStatus(\"connecting\");\r\n    try {\r\n      await this.adapter.open();\r\n      // _onOpen will be called by adapter async event\r\n    } catch (e: any) {\r\n      this.retries++;\r\n      this.setError(e);\r\n      if (\r\n        this.opts.autoReconnect &&\r\n        this.retries <= (this.opts.maxRetries ?? 10)\r\n      ) {\r\n        const delay = this.backoff.next();\r\n        setTimeout(() => this.open(), delay);\r\n      }\r\n    }\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    this.setStatus(\"closing\");\r\n    try {\r\n      await this.adapter?.close();\r\n    } finally {\r\n      this.setStatus(\"closed\");\r\n    }\r\n  }\r\n\r\n  send(data: unknown) {\r\n    this.adapter?.send?.(data);\r\n  }\r\n\r\n  on<T extends keyof ListenerMap>(evt: T, cb: ListenerMap[T][number]) {\r\n    this.listeners[evt].push(cb as any);\r\n    return () => this.off(evt, cb as any);\r\n  }\r\n\r\n  off<T extends keyof ListenerMap>(evt: T, cb: ListenerMap[T][number]) {\r\n    const arr = this.listeners[evt];\r\n    const i = arr.indexOf(cb as any);\r\n    if (i >= 0) arr.splice(i, 1);\r\n  }\r\n\r\n  private emit<T extends keyof ListenerMap>(evt: T, payload?: any) {\r\n    for (const cb of this.listeners[evt]) (cb as any)(payload);\r\n  }\r\n}\r\n","import { StreamCore } from \"../core/Stream\";\r\nimport { BaseOptions } from \"../core/types\";\r\n\r\nexport interface WebSocketOptions extends BaseOptions {\r\n  type: \"websocket\";\r\n  url: string;\r\n  protocols?: string | string[];\r\n}\r\n\r\nexport function websocketAdapter(core: StreamCore, opts: WebSocketOptions) {\r\n  let ws: WebSocket | null = null;\r\n\r\n  return {\r\n    open() {\r\n      ws = new WebSocket(opts.url, opts.protocols);\r\n      ws.onopen = () => core._onOpen();\r\n      ws.onclose = () => core._onClose();\r\n      ws.onerror = (ev: Event) => core._onError(new Error(\"WebSocket error\"));\r\n      ws.onmessage = (ev: MessageEvent) => {\r\n        let data: unknown = ev.data;\r\n        try {\r\n          data = JSON.parse(ev.data);\r\n        } catch {}\r\n        core._onMessage(data);\r\n      };\r\n    },\r\n    close() {\r\n      ws?.close();\r\n    },\r\n    send(data: unknown) {\r\n      const payload = typeof data === \"string\" ? data : JSON.stringify(data);\r\n      ws?.send(payload);\r\n    },\r\n  };\r\n}\r\n","import { StreamCore } from \"../core/Stream\";\r\nimport { BaseOptions } from \"../core/types\";\r\n\r\nexport interface SSEOptions extends BaseOptions {\r\n  type: \"sse\";\r\n  url: string;\r\n  withCredentials?: boolean;\r\n}\r\n\r\nexport function sseAdapter(core: StreamCore, opts: SSEOptions) {\r\n  let es: EventSource | null = null;\r\n\r\n  return {\r\n    open() {\r\n      es = new EventSource(opts.url, {\r\n        withCredentials: !!opts.withCredentials,\r\n      });\r\n      es.onopen = () => core._onOpen();\r\n      es.onerror = () => core._onError(new Error(\"SSE error\"));\r\n      es.onmessage = (e) => {\r\n        let data: unknown = e.data;\r\n        try {\r\n          data = JSON.parse(e.data);\r\n        } catch {}\r\n        core._onMessage(data);\r\n      };\r\n    },\r\n    close() {\r\n      es?.close();\r\n    },\r\n  };\r\n}\r\n","import { StreamCore } from \"../core/Stream\";\r\nimport { BaseOptions } from \"../core/types\";\r\n\r\nexport interface HTTPStreamOptions extends BaseOptions {\r\n  type: \"http\";\r\n  url: string;\r\n  requestInit?: RequestInit;\r\n}\r\n\r\nexport function httpStreamAdapter(core: StreamCore, opts: HTTPStreamOptions) {\r\n  let ctrl: AbortController | null = null;\r\n\r\n  return {\r\n    async open() {\r\n      ctrl = new AbortController();\r\n      try {\r\n        const res = await fetch(opts.url, {\r\n          ...(opts.requestInit || {}),\r\n          signal: ctrl.signal,\r\n        });\r\n        if (!res.body) throw new Error(\"No body for HTTP stream\");\r\n        core._onOpen();\r\n        const reader = res.body.getReader();\r\n        const decoder = new TextDecoder();\r\n        while (true) {\r\n          const { value, done } = await reader.read();\r\n          if (done) break;\r\n          const chunk = decoder.decode(value, { stream: true });\r\n          // حاول تقطيع حسب newline أو JSONL\r\n          chunk\r\n            .split(/\\r?\\n/)\r\n            .filter(Boolean)\r\n            .forEach((line) => {\r\n              let data: unknown = line;\r\n              try {\r\n                data = JSON.parse(line);\r\n              } catch {}\r\n              core._onMessage(data);\r\n            });\r\n        }\r\n        core._onClose();\r\n      } catch (e: any) {\r\n        if (e.name !== \"AbortError\") core._onError(e);\r\n      }\r\n    },\r\n    async close() {\r\n      ctrl?.abort();\r\n    },\r\n  };\r\n}\r\n","import { StreamCore } from \"../core/Stream\";\r\nimport { BaseOptions } from \"../core/types\";\r\n\r\nexport interface LongPollingOptions extends BaseOptions {\r\n  type: \"long-polling\";\r\n  url: string;\r\n  intervalMs?: number; // fallback عند الفشل\r\n  requestInit?: RequestInit;\r\n}\r\n\r\nexport function longPollingAdapter(core: StreamCore, opts: LongPollingOptions) {\r\n  let stopped = false;\r\n\r\n  async function loop() {\r\n    while (!stopped) {\r\n      try {\r\n        const res = await fetch(opts.url, opts.requestInit);\r\n        const text = await res.text();\r\n        const lines = text.split(/\\r?\\n/).filter(Boolean);\r\n        for (const line of lines) {\r\n          let data: unknown = line;\r\n          try {\r\n            data = JSON.parse(line);\r\n          } catch {}\r\n          core._onMessage(data);\r\n        }\r\n        // لو السيرفر بيرجع فورًا، استنى interval\r\n        await new Promise((r) => setTimeout(r, opts.intervalMs ?? 3000));\r\n      } catch (e: any) {\r\n        core._onError(e);\r\n        await new Promise((r) => setTimeout(r, opts.intervalMs ?? 3000));\r\n      }\r\n    }\r\n    core._onClose();\r\n  }\r\n\r\n  return {\r\n    async open() {\r\n      stopped = false;\r\n      core._onOpen();\r\n      loop();\r\n    },\r\n    async close() {\r\n      stopped = true;\r\n    },\r\n  };\r\n}\r\n","import { StreamCore } from \"../core/Stream\";\r\nimport { BaseOptions } from \"../core/types\";\r\n\r\nexport interface HLSOptions extends BaseOptions {\r\n  type: \"hls\";\r\n  url: string; // m3u8\r\n  video: HTMLVideoElement; // عنصر الفيديو لاستقبال الستريم\r\n}\r\n\r\nexport function hlsAdapter(core: StreamCore, opts: HLSOptions) {\r\n  let HlsLib: any;\r\n  let hls: any;\r\n\r\n  return {\r\n    async open() {\r\n      try {\r\n        // إن كان المتصفح يدعم HLS natively (Safari مثلًا)\r\n        if (opts.video.canPlayType(\"application/vnd.apple.mpegURL\")) {\r\n          opts.video.src = opts.url;\r\n          opts.video.addEventListener(\"loadedmetadata\", () => {\r\n            core._onOpen();\r\n            core._onMessage({ event: \"hls:loaded\" });\r\n          });\r\n          opts.video.addEventListener(\"error\", () =>\r\n            core._onError(new Error(\"HLS video error\"))\r\n          );\r\n          return;\r\n        }\r\n        // استخدام hls.js (peer dep)\r\n        const mod = await import(\"hls.js\");\r\n        HlsLib = mod.default || mod;\r\n        if (!HlsLib.isSupported()) throw new Error(\"hls.js not supported\");\r\n        hls = new HlsLib();\r\n        hls.on(HlsLib.Events.ERROR, (_e: any, data: any) =>\r\n          core._onError(new Error(`HLS: ${data?.details || \"error\"}`))\r\n        );\r\n        hls.on(HlsLib.Events.MANIFEST_PARSED, () =>\r\n          core._onMessage({ event: \"hls:manifest_parsed\" })\r\n        );\r\n        hls.loadSource(opts.url);\r\n        hls.attachMedia(opts.video);\r\n        core._onOpen();\r\n      } catch (e: any) {\r\n        core._onError(e);\r\n      }\r\n    },\r\n    async close() {\r\n      try {\r\n        if (hls) hls.destroy();\r\n      } catch {}\r\n      opts.video.removeAttribute(\"src\");\r\n      opts.video.load();\r\n      core._onClose();\r\n    },\r\n  };\r\n}\r\n","import { StreamCore } from \"../core/Stream\";\r\nimport { BaseOptions } from \"../core/types\";\r\n\r\nexport interface WebRTCOptions extends BaseOptions {\r\n  type: \"webrtc\";\r\n  createPeer: () => RTCPeerConnection;\r\n  onTrack: (stream: MediaStream) => void; // تربطها بعنصر فيديو/أوديو\r\n  dataChannelLabel?: string;\r\n}\r\n\r\nexport function webrtcAdapter(core: StreamCore, opts: WebRTCOptions) {\r\n  let pc: RTCPeerConnection | null = null;\r\n  let dc: RTCDataChannel | null = null;\r\n\r\n  return {\r\n    async open() {\r\n      pc = opts.createPeer();\r\n      dc = pc.createDataChannel(opts.dataChannelLabel || \"data\");\r\n      dc.onopen = () => core._onOpen();\r\n      dc.onmessage = (e) => core._onMessage(e.data);\r\n      dc.onerror = () => core._onError(new Error(\"WebRTC data channel error\"));\r\n      dc.onclose = () => core._onClose();\r\n      pc.ontrack = (e) => opts.onTrack(e.streams[0]);\r\n      // باقي الـ signaling خارج هذا الأداپتر\r\n    },\r\n    async close() {\r\n      dc?.close();\r\n      pc?.close();\r\n      core._onClose();\r\n    },\r\n    send(data: unknown) {\r\n      dc?.send(typeof data === \"string\" ? data : JSON.stringify(data));\r\n    },\r\n  };\r\n}\r\n","import { StreamCore } from \"./core/Stream\";\r\nimport { BaseOptions, StreamAPI, ListenerMap } from \"./core/types\";\r\nimport { websocketAdapter, WebSocketOptions } from \"./adapters/websocket\";\r\nimport { sseAdapter, SSEOptions } from \"./adapters/sse\";\r\nimport { httpStreamAdapter, HTTPStreamOptions } from \"./adapters/http\";\r\nimport { longPollingAdapter, LongPollingOptions } from \"./adapters/longPolling\";\r\nimport { hlsAdapter, HLSOptions } from \"./adapters/hls\";\r\nimport { webrtcAdapter, WebRTCOptions } from \"./adapters/webrtc\";\r\n\r\ntype AnyOptions =\r\n  | WebSocketOptions\r\n  | SSEOptions\r\n  | HTTPStreamOptions\r\n  | LongPollingOptions\r\n  | HLSOptions\r\n  | WebRTCOptions;\r\n\r\nexport function createStream(opts: AnyOptions): StreamAPI {\r\n  let adapter;\r\n  // placeholder core—سيتم تمريره فوريًا\r\n  // هننشئ core بدون adapter ثم نربطه:\r\n  // لكن عمليًا بنمرر core للadapter factories.\r\n  const dummy = {} as any;\r\n\r\n  const core = new StreamCore(dummy, opts as BaseOptions);\r\n\r\n  switch (opts.type) {\r\n    case \"websocket\":\r\n      adapter = websocketAdapter(core, opts);\r\n      break;\r\n    case \"sse\":\r\n      adapter = sseAdapter(core, opts);\r\n      break;\r\n    case \"http\":\r\n      adapter = httpStreamAdapter(core, opts);\r\n      break;\r\n    case \"long-polling\":\r\n      adapter = longPollingAdapter(core, opts);\r\n      break;\r\n    case \"hls\":\r\n      adapter = hlsAdapter(core, opts);\r\n      break;\r\n    case \"webrtc\":\r\n      adapter = webrtcAdapter(core, opts);\r\n      break;\r\n    default:\r\n      throw new Error(`Unknown stream type: ${(opts as any).type}`);\r\n  }\r\n\r\n  // اربط الـadapter الحقيقي\r\n  (core as any).adapter = adapter;\r\n\r\n  return {\r\n    open: () => core.open(),\r\n    close: () => core.close(),\r\n    send: (d: unknown) => core.send(d),\r\n    on<T extends keyof ListenerMap>(evt: T, cb: ListenerMap[T][number]) {\r\n      return core.on(evt, cb as any);\r\n    },\r\n    off<T extends keyof ListenerMap>(evt: T, cb: ListenerMap[T][number]) {\r\n      return core.off(evt, cb as any);\r\n    },\r\n    get state() {\r\n      return core.state;\r\n    },\r\n  };\r\n}\r\n\r\nexport * from \"./core/types\";\r\n"],"mappings":"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","names":[]}