<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>js-streaming - Universal JavaScript Streaming Library</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css"
    />

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/hls.js/0.5.14/hls.js"
      integrity="sha512-Uxb1LSW1XkMpEWsi4HguYGAHbXnNP5h0On1bBlSOZmEe42ajm2TCVy6khtfr5jFfjlToaG/mrN6R5zslmOCnAg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <style>
      :root {
        --primary: #6366f1;
        --primary-dark: #4f46e5;
        --secondary: #ec4899;
        --accent: #06b6d4;
        --success: #10b981;
        --warning: #f59e0b;
        --error: #ef4444;
        --bg-primary: #0a0a0a;
        --bg-secondary: #1a1a1a;
        --bg-tertiary: #2a2a2a;
        --text-primary: #ffffff;
        --text-secondary: #a3a3a3;
        --text-muted: #666666;
        --border: rgba(255, 255, 255, 0.1);
        --glass: rgba(255, 255, 255, 0.05);
        --glass-border: rgba(255, 255, 255, 0.1);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        scroll-behavior: smooth;
      }

      body {
        font-family: "Inter", sans-serif;
        background: var(--bg-primary);
        color: var(--text-primary);
        line-height: 1.6;
        overflow-x: hidden;
      }

      /* Gradient Background */
      .bg-gradient {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 20% 80%,
            rgba(120, 119, 198, 0.3) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 20%,
            rgba(255, 119, 198, 0.15) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 40% 40%,
            rgba(120, 219, 255, 0.1) 0%,
            transparent 50%
          );
        z-index: -2;
      }

      /* Animated particles */
      .particles {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
      }

      .particle {
        position: absolute;
        background: var(--primary);
        border-radius: 50%;
        pointer-events: none;
        animation: float 6s ease-in-out infinite;
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0px) rotate(0deg);
        }
        50% {
          transform: translateY(-20px) rotate(180deg);
        }
      }

      /* Navigation */
      .navbar {
        position: fixed;
        top: 0;
        width: 100%;
        padding: 1rem 2rem;
        background: rgba(10, 10, 10, 0.8);
        backdrop-filter: blur(20px);
        border-bottom: 1px solid var(--border);
        z-index: 1000;
        transition: all 0.3s ease;
      }

      .navbar.scrolled {
        background: rgba(10, 10, 10, 0.95);
        padding: 0.75rem 2rem;
      }

      .nav-container {
        max-width: 1200px;
        margin: 0 auto;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .logo {
        font-size: 1.5rem;
        font-weight: 800;
        color: var(--primary);
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .logo::before {
        content: "⚡";
        font-size: 1.8rem;
      }

      .nav-links {
        display: flex;
        gap: 2rem;
        list-style: none;
      }

      .nav-links a {
        color: var(--text-secondary);
        text-decoration: none;
        font-weight: 500;
        transition: color 0.3s ease;
        position: relative;
      }

      .nav-links a:hover {
        color: var(--text-primary);
      }

      .nav-links a::after {
        content: "";
        position: absolute;
        bottom: -5px;
        left: 0;
        width: 0;
        height: 2px;
        background: var(--primary);
        transition: width 0.3s ease;
      }

      .nav-links a:hover::after {
        width: 100%;
      }

      /* Container */
      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 2rem;
      }

      /* Hero Section */
      .hero {
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 6rem 0 4rem;
      }

      .hero-content {
        max-width: 800px;
      }

      .hero-badge {
        display: inline-block;
        background: var(--glass);
        border: 1px solid var(--glass-border);
        backdrop-filter: blur(10px);
        padding: 0.75rem 1.5rem;
        border-radius: 50px;
        font-size: 0.875rem;
        margin-bottom: 2rem;
        color: var(--text-secondary);
      }

      .hero h1 {
        font-size: clamp(2.5rem, 5vw, 4rem);
        font-weight: 800;
        margin-bottom: 1.5rem;
        background: linear-gradient(
          135deg,
          var(--text-primary) 0%,
          var(--primary) 100%
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .hero p {
        font-size: clamp(1.125rem, 2vw, 1.25rem);
        color: var(--text-secondary);
        margin-bottom: 2.5rem;
        line-height: 1.7;
      }

      .hero-buttons {
        display: flex;
        gap: 1rem;
        justify-content: center;
        flex-wrap: wrap;
      }

      .btn {
        padding: 0.875rem 1.75rem;
        border-radius: 50px;
        font-weight: 600;
        text-decoration: none;
        transition: all 0.3s ease;
        border: none;
        cursor: pointer;
        font-size: 1rem;
      }

      .btn-primary {
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        color: white;
        box-shadow: 0 10px 25px rgba(99, 102, 241, 0.3);
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 15px 35px rgba(99, 102, 241, 0.4);
      }

      .btn-secondary {
        background: var(--glass);
        color: var(--text-primary);
        border: 1px solid var(--glass-border);
        backdrop-filter: blur(10px);
      }

      .btn-secondary:hover {
        background: var(--bg-tertiary);
        transform: translateY(-2px);
      }

      /* Stats */
      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 2rem;
        margin-top: 4rem;
      }

      .stat-card {
        text-align: center;
        padding: 1.5rem;
        background: var(--glass);
        border: 1px solid var(--glass-border);
        border-radius: 1rem;
        backdrop-filter: blur(10px);
      }

      .stat-number {
        font-size: 2.5rem;
        font-weight: 800;
        color: var(--primary);
        display: block;
      }

      .stat-label {
        color: var(--text-secondary);
        font-size: 0.875rem;
        margin-top: 0.5rem;
      }

      /* Protocols Section */
      .protocols {
        padding: 6rem 0;
        background: linear-gradient(
          135deg,
          var(--bg-secondary) 0%,
          var(--bg-primary) 100%
        );
      }

      .section-header {
        text-align: center;
        margin-bottom: 4rem;
      }

      .section-title {
        font-size: clamp(2rem, 4vw, 3rem);
        font-weight: 800;
        margin-bottom: 1rem;
      }

      .section-subtitle {
        font-size: 1.125rem;
        color: var(--text-secondary);
        max-width: 600px;
        margin: 0 auto;
      }

      .protocols-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 2rem;
      }

      .protocol-card {
        background: var(--glass);
        border: 1px solid var(--glass-border);
        border-radius: 1.5rem;
        padding: 2rem;
        backdrop-filter: blur(10px);
        transition: all 0.3s ease;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }

      .protocol-card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 3px;
        background: linear-gradient(90deg, var(--primary), var(--secondary));
      }

      .protocol-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        border-color: rgba(255, 255, 255, 0.2);
      }

      .protocol-icon {
        width: 60px;
        height: 60px;
        border-radius: 1rem;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        margin-bottom: 1.5rem;
        background: var(--bg-tertiary);
      }

      .protocol-card h3 {
        font-size: 1.25rem;
        font-weight: 700;
        margin-bottom: 0.75rem;
        color: var(--text-primary);
      }

      .protocol-card p {
        color: var(--text-secondary);
        margin-bottom: 1.5rem;
      }

      .protocol-features {
        list-style: none;
      }

      .protocol-features li {
        color: var(--text-secondary);
        padding: 0.25rem 0;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .protocol-features li::before {
        content: "✓";
        color: var(--success);
        font-weight: bold;
      }

      /* Demo Section */
      .demo {
        padding: 6rem 0;
        background: var(--bg-primary);
      }

      .demo-container {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 2rem;
        padding: 3rem;
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
      }

      .demo-tabs {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 2rem;
        background: var(--bg-tertiary);
        border-radius: 1rem;
        padding: 0.5rem;
        overflow-x: auto;
      }

      .demo-tab {
        padding: 0.75rem 1.5rem;
        border-radius: 0.75rem;
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        transition: all 0.3s ease;
        white-space: nowrap;
      }

      .demo-tab.active {
        background: var(--primary);
        color: white;
      }

      .demo-content {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 2rem;
      }

      .demo-panel {
        background: var(--bg-tertiary);
        border-radius: 1rem;
        padding: 1.5rem;
        border: 1px solid var(--border);
      }

      .demo-panel h4 {
        margin-bottom: 1.5rem;
        font-size: 1.125rem;
        font-weight: 600;
      }

      .form-group {
        margin-bottom: 1rem;
      }

      .form-label {
        display: block;
        margin-bottom: 0.5rem;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .form-control {
        width: 100%;
        padding: 0.75rem;
        background: var(--bg-primary);
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        color: var(--text-primary);
        font-size: 0.875rem;
      }

      .form-control:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
      }

      .status-indicator {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 1rem;
        padding: 0.75rem;
        background: var(--bg-primary);
        border-radius: 0.5rem;
        border: 1px solid var(--border);
      }

      .status-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: var(--text-muted);
      }

      .status-dot.connected {
        background: var(--success);
        animation: pulse 2s infinite;
      }

      .status-dot.connecting {
        background: var(--warning);
        animation: pulse 1s infinite;
      }

      .status-dot.error {
        background: var(--error);
      }

      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      .logs {
        background: var(--bg-primary);
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        padding: 1rem;
        height: 300px;
        overflow-y: auto;
        font-family: "Courier New", monospace;
        font-size: 0.8rem;
        line-height: 1.4;
      }

      .log-entry {
        margin-bottom: 0.5rem;
        padding: 0.25rem;
      }

      .log-entry.info {
        color: var(--accent);
      }
      .log-entry.success {
        color: var(--success);
      }
      .log-entry.error {
        color: var(--error);
      }
      .log-entry.warning {
        color: var(--warning);
      }

      .log-time {
        color: var(--text-muted);
        margin-right: 0.5rem;
      }

      /* Examples Section */
      .examples {
        padding: 6rem 0;
        background: var(--bg-secondary);
      }

      .examples-nav {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 2rem;
        justify-content: center;
        flex-wrap: wrap;
      }

      .example-tab {
        padding: 0.75rem 1.5rem;
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        color: var(--text-secondary);
        text-decoration: none;
        transition: all 0.3s ease;
        cursor: pointer;
      }

      .example-tab.active,
      .example-tab:hover {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
      }

      .example-container {
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        border-radius: 1rem;
        overflow: hidden;
      }

      .example-header {
        padding: 1rem 1.5rem;
        background: var(--bg-primary);
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .example-title {
        font-weight: 600;
      }

      .copy-btn {
        padding: 0.5rem 1rem;
        background: var(--accent);
        color: white;
        border: none;
        border-radius: 0.5rem;
        cursor: pointer;
        font-size: 0.875rem;
        transition: all 0.3s ease;
      }

      .copy-btn:hover {
        background: var(--primary);
      }

      .example-code {
        padding: 1.5rem;
        background: var(--bg-primary);
        overflow-x: auto;
      }

      .example-code pre {
        margin: 0;
        font-size: 0.875rem;
        line-height: 1.5;
      }

      /* Footer */
      .footer {
        padding: 4rem 0 2rem;
        background: var(--bg-primary);
        border-top: 1px solid var(--border);
      }

      .footer-content {
        display: grid;
        grid-template-columns: 2fr 1fr 1fr 1fr;
        gap: 2rem;
        margin-bottom: 2rem;
      }

      .footer-section h4 {
        margin-bottom: 1rem;
        color: var(--text-primary);
        font-weight: 600;
      }

      .footer-links {
        list-style: none;
      }

      .footer-links li {
        margin-bottom: 0.5rem;
      }

      .footer-links a {
        color: var(--text-secondary);
        text-decoration: none;
        transition: color 0.3s ease;
      }

      .footer-links a:hover {
        color: var(--text-primary);
      }

      .footer-bottom {
        text-align: center;
        padding-top: 2rem;
        border-top: 1px solid var(--border);
        color: var(--text-muted);
      }

      /* Video Container */
      .video-container {
        width: 100%;
        background: black;
        border-radius: 0.5rem;
        overflow: hidden;
        margin: 1rem 0;
        display: none;
      }

      .video-container.show {
        display: block;
      }

      .video-container video {
        width: 100%;
        height: auto;
      }

      /* Responsive */
      @media (max-width: 768px) {
        .nav-links {
          display: none;
        }

        .hero-buttons {
          flex-direction: column;
          align-items: center;
        }

        .demo-content {
          grid-template-columns: 1fr;
        }

        .footer-content {
          grid-template-columns: 1fr;
          text-align: center;
        }

        .examples-nav {
          display: grid;
          grid-template-columns: repeat(2, 1fr);
          gap: 0.5rem;
        }
      }
    </style>
  </head>
  <body>
    <!-- Background -->
    <div class="bg-gradient"></div>
    <div class="particles" id="particles"></div>

    <!-- Navigation -->
    <nav class="navbar" id="navbar">
      <div class="nav-container">
        <a href="#" class="logo">js-streaming</a>
        <ul class="nav-links">
          <li><a href="#protocols">Protocols</a></li>
          <li><a href="#demo">Demo</a></li>
          <li><a href="#examples">Examples</a></li>
          <li>
            <a href="https://github.com/js-streaming" target="_blank">GitHub</a>
          </li>
        </ul>
      </div>
    </nav>

    <!-- Hero Section -->
    <section class="hero">
      <div class="container">
        <div class="hero-content">
          <div class="hero-badge">
            ⚡ Universal Streaming • Zero Dependencies • TypeScript Ready
          </div>
          <h1>One Library, Every Protocol</h1>
          <p>
            The most advanced JavaScript streaming library. Support WebSocket,
            SSE, HTTP streaming, long-polling, HLS video, and WebRTC with a
            single, unified API.
          </p>
          <div class="hero-buttons">
            <a href="#demo" class="btn btn-primary">🚀 Try Live Demo</a>
            <a href="#examples" class="btn btn-secondary">📚 View Examples</a>
          </div>
          <div class="stats">
            <div class="stat-card">
              <span class="stat-number">6</span>
              <span class="stat-label">Protocols Supported</span>
            </div>
            <div class="stat-card">
              <span class="stat-number">0</span>
              <span class="stat-label">Dependencies</span>
            </div>
            <div class="stat-card">
              <span class="stat-number">&lt; 50KB</span>
              <span class="stat-label">Bundle Size</span>
            </div>
            <div class="stat-card">
              <span class="stat-number">100%</span>
              <span class="stat-label">TypeScript</span>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Protocols Section -->
    <section class="protocols" id="protocols">
      <div class="container">
        <div class="section-header">
          <h2 class="section-title">All Protocols, One API</h2>
          <p class="section-subtitle">
            Seamlessly switch between different streaming protocols with
            intelligent fallbacks and auto-reconnection
          </p>
        </div>
        <div class="protocols-grid">
          <div class="protocol-card" data-protocol="websocket">
            <div class="protocol-icon">🔌</div>
            <h3>WebSocket</h3>
            <p>
              Full-duplex real-time communication with automatic reconnection
              and message buffering.
            </p>
            <ul class="protocol-features">
              <li>Bidirectional messaging</li>
              <li>Low latency communication</li>
              <li>Binary & text support</li>
              <li>Connection pooling</li>
            </ul>
          </div>

          <div class="protocol-card" data-protocol="sse">
            <div class="protocol-icon">📡</div>
            <h3>Server-Sent Events</h3>
            <p>
              Efficient server-to-client streaming with built-in reconnection
              and event routing.
            </p>
            <ul class="protocol-features">
              <li>Native browser support</li>
              <li>Automatic reconnection</li>
              <li>Event-based messaging</li>
              <li>HTTP/2 compatible</li>
            </ul>
          </div>

          <div class="protocol-card" data-protocol="http">
            <div class="protocol-icon">🌊</div>
            <h3>HTTP Streaming</h3>
            <p>
              Stream data over regular HTTP connections with chunked transfer
              encoding support.
            </p>
            <ul class="protocol-features">
              <li>Universal compatibility</li>
              <li>Chunked streaming</li>
              <li>Custom headers support</li>
              <li>Progress tracking</li>
            </ul>
          </div>

          <div class="protocol-card" data-protocol="longpolling">
            <div class="protocol-icon">🔄</div>
            <h3>Long Polling</h3>
            <p>
              Simulate real-time communication with intelligent polling and
              backoff strategies.
            </p>
            <ul class="protocol-features">
              <li>Fallback compatibility</li>
              <li>Smart polling intervals</li>
              <li>Error recovery</li>
              <li>Resource efficient</li>
            </ul>
          </div>

          <div class="protocol-card" data-protocol="hls">
            <div class="protocol-icon">🎥</div>
            <h3>HLS Video Streaming</h3>
            <p>
              HTTP Live Streaming with native Safari support and hls.js fallback
              for other browsers.
            </p>
            <ul class="protocol-features">
              <li>Adaptive bitrate</li>
              <li>Cross-platform support</li>
              <li>Native & hls.js fallback</li>
              <li>Live & VOD streaming</li>
            </ul>
          </div>

          <div class="protocol-card" data-protocol="webrtc">
            <div class="protocol-icon">🚀</div>
            <h3>WebRTC Data Channels</h3>
            <p>
              Peer-to-peer real-time communication with ultra-low latency and
              media streaming support.
            </p>
            <ul class="protocol-features">
              <li>Peer-to-peer connection</li>
              <li>Ultra-low latency</li>
              <li>Media streaming</li>
              <li>NAT traversal</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <!-- Demo Section -->
    <section class="demo" id="demo">
      <div class="container">
        <div class="section-header">
          <h2 class="section-title">Interactive Demo</h2>
          <p class="section-subtitle">
            Test all streaming protocols with real-time monitoring and live
            configuration
          </p>
        </div>

        <div class="demo-container">
          <div class="demo-tabs">
            <button class="demo-tab active" data-protocol="websocket">
              🔌 WebSocket
            </button>
            <button class="demo-tab" data-protocol="sse">📡 SSE</button>
            <button class="demo-tab" data-protocol="http">🌊 HTTP</button>
            <button class="demo-tab" data-protocol="longpolling">
              🔄 Long Poll
            </button>
            <button class="demo-tab" data-protocol="hls">🎥 HLS</button>
            <button class="demo-tab" data-protocol="webrtc">🚀 WebRTC</button>
          </div>

          <div class="demo-content">
            <!-- Controls -->
            <div class="demo-panel">
              <h4>🎛️ Configuration</h4>

              <div class="form-group">
                <label class="form-label">Stream URL</label>
                <input
                  type="text"
                  class="form-control"
                  id="streamUrl"
                  value="wss://echo.websocket.org"
                />
              </div>

              <div class="form-group">
                <label class="form-label">Auto Reconnect</label>
                <select class="form-control" id="autoReconnect">
                  <option value="true">Enabled</option>
                  <option value="false">Disabled</option>
                </select>
              </div>

              <div class="form-group">
                <label class="form-label">Max Retries</label>
                <input
                  type="number"
                  class="form-control"
                  id="maxRetries"
                  value="5"
                  min="0"
                  max="20"
                />
              </div>

              <!-- Video Container for HLS -->
              <div class="video-container" id="videoContainer">
                <video id="videoPlayer" controls muted></video>
              </div>

              <!-- Send Message -->
              <div
                class="form-group"
                id="sendMessageGroup"
                style="display: none"
              >
                <label class="form-label">Send Message</label>
                <div style="display: flex; gap: 0.5rem">
                  <input
                    type="text"
                    class="form-control"
                    id="messageInput"
                    placeholder="Type message..."
                  />
                  <button class="btn btn-primary" id="sendBtn">Send</button>
                </div>
              </div>

              <!-- Control Buttons -->
              <div style="display: flex; gap: 0.5rem; margin-top: 1.5rem">
                <button class="btn btn-primary" id="connectBtn">Connect</button>
                <button class="btn btn-secondary" id="disconnectBtn" disabled>
                  Disconnect
                </button>
                <button class="btn btn-secondary" id="clearBtn">Clear</button>
              </div>
            </div>

            <!-- Status & Logs -->
            <div class="demo-panel">
              <h4>📊 Live Monitoring</h4>

              <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Disconnected</span>
              </div>

              <div
                style="
                  display: grid;
                  grid-template-columns: 1fr 1fr;
                  gap: 1rem;
                  margin-bottom: 1rem;
                "
              >
                <div
                  style="
                    text-align: center;
                    padding: 1rem;
                    background: var(--bg-primary);
                    border-radius: 0.5rem;
                  "
                >
                  <div
                    style="
                      font-size: 1.5rem;
                      font-weight: bold;
                      color: var(--primary);
                    "
                    id="messageCount"
                  >
                    0
                  </div>
                  <div style="font-size: 0.8rem; color: var(--text-secondary)">
                    Messages
                  </div>
                </div>
                <div
                  style="
                    text-align: center;
                    padding: 1rem;
                    background: var(--bg-primary);
                    border-radius: 0.5rem;
                  "
                >
                  <div
                    style="
                      font-size: 1.5rem;
                      font-weight: bold;
                      color: var(--success);
                    "
                    id="connectionTime"
                  >
                    0s
                  </div>
                  <div style="font-size: 0.8rem; color: var(--text-secondary)">
                    Uptime
                  </div>
                </div>
              </div>

              <div style="margin-bottom: 1rem">
                <label class="form-label">Activity Log</label>
                <div class="logs" id="logContainer">
                  <div class="log-entry info">
                    <span class="log-time">[--:--:--]</span>
                    <span
                      >Ready to connect. Select a protocol and click
                      Connect.</span
                    >
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Examples Section -->
    <section class="examples" id="examples">
      <div class="container">
        <div class="section-header">
          <h2 class="section-title">Code Examples</h2>
          <p class="section-subtitle">
            Ready-to-use examples for all frameworks and use cases
          </p>
        </div>

        <div class="examples-nav">
          <a class="example-tab active" data-example="basic">Basic Usage</a>
          <a class="example-tab" data-example="react">React Hook</a>
          <a class="example-tab" data-example="vue">Vue Composable</a>
          <a class="example-tab" data-example="hls">HLS Streaming</a>
          <a class="example-tab" data-example="webrtc">WebRTC</a>
          <a class="example-tab" data-example="advanced">Advanced</a>
        </div>

        <div class="example-container">
          <div class="example-header">
            <span class="example-title" id="exampleTitle">Basic Usage</span>
            <button class="copy-btn" onclick="copyCode()">📋 Copy</button>
          </div>
          <div class="example-code">
            <pre
              id="codeBlock"
            ><code class="language-javascript">// Install the library
npm install js-streaming

// Basic WebSocket example
import { createStream } from 'js-streaming';

const stream = createStream({
  type: 'websocket',
  url: 'wss://api.example.com/ws',
  autoReconnect: true,
  maxRetries: 5
});

// Listen for events
stream.on('open', () => {
  console.log('✅ Connected!');
});

stream.on('message', (data) => {
  console.log('📨 Received:', data);
});

stream.on('error', (error) => {
  console.error('❌ Error:', error);
});

stream.on('close', () => {
  console.log('🔴 Disconnected');
});

// Connect and send data
await stream.open();
stream.send({ message: 'Hello World!' });</code></pre>
          </div>
        </div>
      </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
      <div class="container">
        <div class="footer-content">
          <div class="footer-section">
            <h4>js-streaming</h4>
            <p style="color: var(--text-secondary); margin-bottom: 1rem">
              The most advanced streaming library for JavaScript. Built with
              performance and developer experience in mind.
            </p>
            <div style="display: flex; gap: 1rem">
              <a
                href="https://github.com/js-streaming"
                style="color: var(--primary)"
                >GitHub</a
              >
              <a
                href="https://npmjs.com/package/js-streaming"
                style="color: var(--primary)"
                >npm</a
              >
            </div>
          </div>

          <div class="footer-section">
            <h4>Documentation</h4>
            <ul class="footer-links">
              <li><a href="#">Getting Started</a></li>
              <li><a href="#">API Reference</a></li>
              <li><a href="#">Examples</a></li>
              <li><a href="#">Migration Guide</a></li>
            </ul>
          </div>

          <div class="footer-section">
            <h4>Community</h4>
            <ul class="footer-links">
              <li><a href="#">GitHub Discussions</a></li>
              <li><a href="#">Discord Server</a></li>
              <li><a href="#">Stack Overflow</a></li>
              <li><a href="#">Twitter</a></li>
            </ul>
          </div>

          <div class="footer-section">
            <h4>Resources</h4>
            <ul class="footer-links">
              <li><a href="#">Changelog</a></li>
              <li><a href="#">Contributing</a></li>
              <li><a href="#">License</a></li>
              <li><a href="#">Security</a></li>
            </ul>
          </div>
        </div>

        <div class="footer-bottom">
          <p>&copy; 2024 js-streaming. Released under the MIT License.</p>
        </div>
      </div>
    </footer>

    <script type="module">
      import {
        javascript,
        jsx,
        vue,
        hls,
        webrtc,
        advanced,
      } from "./examples.js";

      // Global variables
      let currentStream = null;
      let startTime = null;
      let updateInterval = null;

      // Protocol configurations
      const protocols = {
        websocket: {
          name: "WebSocket",
          url: "wss://echo.websocket.org",
          canSend: true,
          hasVideo: false,
        },
        sse: {
          name: "Server-Sent Events",
          url: "https://demo.mercure.rocks/.well-known/mercure",
          canSend: false,
          hasVideo: false,
        },
        http: {
          name: "HTTP Streaming",
          url: "https://httpbin.org/stream/10",
          canSend: false,
          hasVideo: false,
        },
        longpolling: {
          name: "Long Polling",
          url: "https://httpbin.org/delay/2",
          canSend: false,
          hasVideo: false,
        },
        hls: {
          name: "HLS Video Streaming",
          url: "https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8",
          canSend: false,
          hasVideo: true,
        },
        webrtc: {
          name: "WebRTC Data Channels",
          url: "stun:stun.l.google.com:19302",
          canSend: true,
          hasVideo: false,
        },
      };
      // Example Here

      // Code examples
      const examples = {
        basic: {
          title: "Basic Usage",
          language: "javascript",
          code: javascript,
        },
        react: {
          title: "React Hook Integration",
          language: "jsx",
          code: jsx,
        },
        vue: {
          title: "Vue Composable Integration",
          language: "javascript",
          code: vue,
        },
        hls: {
          title: "HLS Streaming",
          language: "javascript",
          code: hls,
        },
        webrtc: {
          title: "WebRTC Data Channels",
          language: "javascript",
          code: webrtc,
        },
        advanced: {
          title: "Advanced Usage",
          language: "javascript",
          code: advanced,
        },
      };

      // Mock Stream class for demo - Fixed version
      class MockStream {
        constructor(config) {
          this.config = config;
          this.isOpen = false;
          this.listeners = {};
          this.messageCount = 0;
          this.mockInterval = null;
          this.retryCount = 0;
          this.reconnectTimeout = null;
        }

        on(event, callback) {
          if (!this.listeners[event]) {
            this.listeners[event] = [];
          }
          this.listeners[event].push(callback);
          return () => this.off(event, callback);
        }

        off(event, callback) {
          if (!this.listeners[event]) return;
          const index = this.listeners[event].indexOf(callback);
          if (index > -1) {
            this.listeners[event].splice(index, 1);
          }
        }

        emit(event, data) {
          if (this.listeners[event]) {
            this.listeners[event].forEach((cb) => {
              try {
                cb(data);
              } catch (error) {
                console.error("Error in event listener:", error);
              }
            });
          }
        }

        async open() {
          if (this.isOpen) return;

          log("info", `Connecting to ${this.config.type.toUpperCase()}...`);
          updateStatus("connecting");

          try {
            // Simulate connection delay
            await new Promise((resolve) =>
              setTimeout(resolve, 1000 + Math.random() * 1500)
            );

            // Simulate occasional failures (20% chance)
            if (Math.random() < 0.2 && this.retryCount === 0) {
              throw new Error("Connection timeout (demo simulation)");
            }

            this.isOpen = true;
            this.retryCount = 0;
            updateStatus("connected");
            this.emit("open");
            log("success", `Connected to ${this.config.type.toUpperCase()}`);

            // Start mock data
            this.startMockData();
          } catch (error) {
            this.handleConnectionError(error);
          }
        }

        handleConnectionError(error) {
          updateStatus("error");
          this.emit("error", error);
          log("error", error.message);

          // Auto-reconnect logic
          if (
            this.config.autoReconnect &&
            this.retryCount < this.config.maxRetries
          ) {
            this.retryCount++;
            const delay = Math.min(
              1000 * Math.pow(2, this.retryCount - 1),
              10000
            );

            log(
              "warning",
              `Retrying in ${delay}ms... (attempt ${this.retryCount}/${this.config.maxRetries})`
            );

            this.reconnectTimeout = setTimeout(() => {
              this.open();
            }, delay);
          }
        }

        close() {
          this.isOpen = false;

          // Clear intervals and timeouts
          if (this.mockInterval) {
            clearInterval(this.mockInterval);
            this.mockInterval = null;
          }
          if (this.reconnectTimeout) {
            clearTimeout(this.reconnectTimeout);
            this.reconnectTimeout = null;
          }

          updateStatus("disconnected");
          this.emit("close");
          log("info", "Connection closed");
        }

        send(data) {
          if (!this.isOpen) {
            log("warning", "Cannot send: not connected");
            return;
          }

          const message =
            typeof data === "string" ? data : JSON.stringify(data);
          log("info", `Sent: ${message}`);

          // Echo for WebSocket
          if (this.config.type === "websocket") {
            setTimeout(() => {
              if (!this.isOpen) return;

              const echo = {
                type: "echo",
                original: data,
                timestamp: new Date().toISOString(),
                id: generateId(),
              };
              this.emit("message", echo);
              log("success", `Echo: ${JSON.stringify(echo)}`);
              updateMessageCount();
            }, 100 + Math.random() * 300);
          }
        }

        startMockData() {
          if (this.config.type === "hls") return; // HLS handles differently

          const generators = {
            websocket: () => ({
              type: "chat",
              user: randomChoice(["Alice", "Bob", "Charlie", "Diana"]),
              message: randomChoice([
                "Hello everyone!",
                "How is everyone doing?",
                "Great to be here!",
                "Nice weather today",
                "Anyone up for a chat?",
              ]),
              timestamp: new Date().toISOString(),
              id: generateId(),
            }),
            sse: () => ({
              event: "stock_update",
              data: {
                symbol: randomChoice(["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA"]),
                price: (150 + Math.random() * 100).toFixed(2),
                change: (Math.random() * 20 - 10).toFixed(2),
                volume: Math.floor(Math.random() * 1000000),
              },
              timestamp: new Date().toISOString(),
            }),
            http: () => ({
              chunk: Math.floor(Math.random() * 1000),
              progress: Math.floor(Math.random() * 100),
              size: Math.floor(Math.random() * 1024) + "KB",
              timestamp: new Date().toISOString(),
            }),
            longpolling: () => ({
              poll: "response",
              data: Math.floor(Math.random() * 100),
              status: randomChoice(["processing", "completed", "pending"]),
              items: Math.floor(Math.random() * 50),
              timestamp: new Date().toISOString(),
            }),
            webrtc: () => ({
              peer: "message",
              type: randomChoice(["data", "media", "control"]),
              payload: "P2P communication data",
              latency: Math.floor(Math.random() * 50) + "ms",
              timestamp: new Date().toISOString(),
            }),
          };

          const generator =
            generators[this.config.type] || generators.websocket;

          this.mockInterval = setInterval(() => {
            if (!this.isOpen) return;

            const message = generator();
            this.emit("message", message);

            const preview = JSON.stringify(message).substring(0, 100);
            log(
              "success",
              `Received: ${preview}${preview.length === 100 ? "..." : ""}`
            );
            updateMessageCount();
          }, 2000 + Math.random() * 4000);
        }
      }

      // Utility functions
      function randomChoice(array) {
        return array[Math.floor(Math.random() * array.length)];
      }

      function generateId() {
        return Math.random().toString(36).substr(2, 9);
      }

      // UI Helper functions - Fixed versions
      function log(type, message) {
        const container = document.getElementById("logContainer");
        if (!container) return;

        const entry = document.createElement("div");
        entry.className = `log-entry ${type}`;

        const time = new Date().toLocaleTimeString();
        entry.innerHTML = `<span class="log-time">[${time}]</span><span>${escapeHtml(
          message
        )}</span>`;

        container.appendChild(entry);
        container.scrollTop = container.scrollHeight;

        // Keep only last 50 entries
        while (container.children.length > 50) {
          container.removeChild(container.firstChild);
        }
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      function updateStatus(status) {
        const dot = document.getElementById("statusDot");
        const text = document.getElementById("statusText");

        if (dot && text) {
          dot.className = `status-dot ${status}`;
          text.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        }
      }

      function updateMessageCount() {
        const count = document.getElementById("messageCount");
        if (count) {
          count.textContent = parseInt(count.textContent || "0") + 1;
        }
      }

      function updateConnectionTime() {
        if (startTime && currentStream && currentStream.isOpen) {
          const elapsed = Math.floor((Date.now() - startTime) / 1000);
          const minutes = Math.floor(elapsed / 60);
          const seconds = elapsed % 60;
          const timeElement = document.getElementById("connectionTime");
          if (timeElement) {
            timeElement.textContent = `${minutes}:${seconds
              .toString()
              .padStart(2, "0")}`;
          }
        }
      }

      function clearLogs() {
        const container = document.getElementById("logContainer");
        if (container) {
          container.innerHTML = `
            <div class="log-entry info">
                <span class="log-time">[${new Date().toLocaleTimeString()}]</span>
                <span>Logs cleared</span>
            </div>
        `;
        }

        const messageCount = document.getElementById("messageCount");
        if (messageCount) {
          messageCount.textContent = "0";
        }
      }

      // Protocol switching - Fixed version
      function switchProtocol(protocolName) {
        const protocol = protocols[protocolName];
        if (!protocol) {
          console.error("Unknown protocol:", protocolName);
          return;
        }

        // Update tabs
        document.querySelectorAll(".demo-tab").forEach((tab) => {
          tab.classList.toggle("active", tab.dataset.protocol === protocolName);
        });

        // Update URL
        const urlInput = document.getElementById("streamUrl");
        if (urlInput) {
          urlInput.value = protocol.url;
        }

        // Show/hide send message
        const sendGroup = document.getElementById("sendMessageGroup");
        if (sendGroup) {
          sendGroup.style.display = protocol.canSend ? "block" : "none";
        }

        // Show/hide video
        const videoContainer = document.getElementById("videoContainer");
        if (videoContainer) {
          videoContainer.classList.toggle("show", protocol.hasVideo);
        }

        // Disconnect current stream
        if (currentStream) {
          disconnect();
        }

        log("info", `Switched to ${protocol.name}`);
      }

      // Connection functions - Fixed versions
      async function connect() {
        const activeTab = document.querySelector(".demo-tab.active");
        if (!activeTab) {
          log("error", "No protocol selected");
          return;
        }

        const protocol = activeTab.dataset.protocol;
        const urlInput = document.getElementById("streamUrl");
        const autoReconnectSelect = document.getElementById("autoReconnect");
        const maxRetriesInput = document.getElementById("maxRetries");

        if (!urlInput || !autoReconnectSelect || !maxRetriesInput) {
          log("error", "Missing form elements");
          return;
        }

        const url = urlInput.value.trim();
        if (!url) {
          log("error", "Please enter a valid URL");
          return;
        }

        const autoReconnect = autoReconnectSelect.value === "true";
        const maxRetries = parseInt(maxRetriesInput.value) || 5;

        if (currentStream) {
          await disconnect();
        }

        const config = { type: protocol, url, autoReconnect, maxRetries };

        try {
          if (protocol === "hls") {
            await connectHLS(config);
          } else {
            currentStream = new MockStream(config);

            currentStream.on("open", () => {
              startTime = Date.now();
              toggleConnectButtons(true);
            });

            currentStream.on("close", () => {
              startTime = null;
              toggleConnectButtons(false);
            });

            currentStream.on("error", (error) => {
              console.error("Stream error:", error);
            });

            await currentStream.open();
          }
        } catch (error) {
          log("error", `Connection failed: ${error.message}`);
        }
      }

      async function connectHLS(config) {
        const video = document.getElementById("videoPlayer");
        if (!video) {
          log("error", "Video element not found");
          return;
        }

        try {
          if (video.canPlayType("application/vnd.apple.mpegURL")) {
            // Native HLS support (Safari)
            video.src = config.url;

            const onLoadedData = () => {
              log("success", "HLS stream loaded (native support)");
              updateStatus("connected");
              startTime = Date.now();
              toggleConnectButtons(true);
              video.removeEventListener("loadeddata", onLoadedData);
              video.removeEventListener("error", onError);
            };

            const onError = (e) => {
              log("error", `HLS error: ${e.message || "Unknown error"}`);
              updateStatus("error");
              video.removeEventListener("loadeddata", onLoadedData);
              video.removeEventListener("error", onError);
            };

            video.addEventListener("loadeddata", onLoadedData);
            video.addEventListener("error", onError);
          } else if (typeof Hls !== "undefined" && Hls.isSupported()) {
            // hls.js support
            const hls = new Hls();
            hls.loadSource(config.url);
            hls.attachMedia(video);

            hls.on(Hls.Events.MANIFEST_PARSED, () => {
              log("success", "HLS stream loaded (hls.js)");
              updateStatus("connected");
              startTime = Date.now();
              toggleConnectButtons(true);
            });

            hls.on(Hls.Events.ERROR, (event, data) => {
              if (data.fatal) {
                switch (data.type) {
                  case Hls.ErrorTypes.NETWORK_ERROR:
                    console.warn("Network error, retrying manifest...");
                    hls.startLoad();
                    break;
                  case Hls.ErrorTypes.MEDIA_ERROR:
                    console.warn("Media error, trying to recover...");
                    hls.recoverMediaError();
                    break;
                  default:
                    hls.destroy();
                    break;
                }
              }
            });
          } else {
            log("info", "HLS.js would be loaded here for full browser support");
            updateStatus("connected");
            startTime = Date.now();
            toggleConnectButtons(true);
          }
        } catch (error) {
          log("error", `HLS setup failed: ${error.message}`);
          updateStatus("error");
        }
      }

      async function disconnect() {
        if (currentStream) {
          await currentStream.close();
          currentStream = null;
        }

        // Reset video
        const video = document.getElementById("videoPlayer");
        if (video && video.src) {
          video.src = "";
          video.load();
        }

        startTime = null;
        toggleConnectButtons(false);
        updateStatus("disconnected");
      }

      function toggleConnectButtons(connected) {
        const connectBtn = document.getElementById("connectBtn");
        const disconnectBtn = document.getElementById("disconnectBtn");

        if (connectBtn && disconnectBtn) {
          connectBtn.disabled = connected;
          disconnectBtn.disabled = !connected;
        }
      }

      function sendMessage() {
        if (!currentStream || !currentStream.isOpen) {
          log("warning", "Not connected");
          return;
        }

        const input = document.getElementById("messageInput");
        if (!input) return;

        const message = input.value.trim();
        if (!message) return;

        currentStream.send({
          text: message,
          timestamp: new Date().toISOString(),
        });
        input.value = "";
      }

      // Example switching - Fixed version
      function switchExample(exampleName) {
        const example = examples[exampleName];
        if (!example) {
          console.error("Unknown example:", exampleName);
          return;
        }

        // Update tabs
        document.querySelectorAll(".example-tab").forEach((tab) => {
          tab.classList.toggle("active", tab.dataset.example === exampleName);
        });

        // Update content
        const titleElement = document.getElementById("exampleTitle");
        const codeElement = document.getElementById("codeBlock");

        if (titleElement) {
          titleElement.textContent = example.title;
        }

        if (codeElement) {
          codeElement.innerHTML = `<code class="language-${
            example.language
          }">${escapeHtml(example.code)}</code>`;

          // Highlight syntax
          if (window.Prism) {
            const codeBlock = codeElement.querySelector("code");
            if (codeBlock) {
              window.Prism.highlightElement(codeBlock);
            }
          }
        }
      }
      function copyCode() {
        const code = document.querySelector("#codeBlock code");
        if (!code) return;

        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard
            .writeText(code.textContent)
            .then(() => {
              const btn = document.querySelector(".copy-btn");
              if (btn) {
                const original = btn.textContent;
                btn.textContent = "✅ Copied!";
                setTimeout(() => (btn.textContent = original), 2000);
              }
            })
            .catch((err) => {
              console.error("Failed to copy:", err);
              fallbackCopyTextToClipboard(code.textContent);
            });
        } else {
          fallbackCopyTextToClipboard(code.textContent);
        }
      }

      function fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-999999px";
        textArea.style.top = "-999999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
          document.execCommand("copy");
          const btn = document.querySelector(".copy-btn");
          if (btn) {
            const original = btn.textContent;
            btn.textContent = "✅ Copied!";
            setTimeout(() => (btn.textContent = original), 2000);
          }
        } catch (err) {
          console.error("Fallback copy failed:", err);
        }

        document.body.removeChild(textArea);
      }

      // Particles animation - Fixed version
      function createParticles() {
        const container = document.getElementById("particles");
        if (!container) return;

        const particleCount = Math.min(50, Math.floor(window.innerWidth / 30));

        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement("div");
          particle.className = "particle";

          const size = Math.random() * 4 + 2;
          const x = Math.random() * window.innerWidth;
          const y = Math.random() * window.innerHeight;
          const duration = Math.random() * 3 + 3;
          const delay = Math.random() * 2;

          particle.style.cssText = `
            width: ${size}px;
            height: ${size}px;
            left: ${x}px;
            top: ${y}px;
            animation-duration: ${duration}s;
            animation-delay: ${delay}s;
            opacity: ${Math.random() * 0.5 + 0.1};
        `;

          container.appendChild(particle);
        }
      }

      // Navbar scroll effect - Fixed version
      function setupNavbar() {
        const navbar = document.getElementById("navbar");
        if (!navbar) return;

        let ticking = false;

        function updateNavbar() {
          if (window.scrollY > 50) {
            navbar.classList.add("scrolled");
          } else {
            navbar.classList.remove("scrolled");
          }
          ticking = false;
        }

        window.addEventListener("scroll", () => {
          if (!ticking) {
            requestAnimationFrame(updateNavbar);
            ticking = true;
          }
        });
      }

      // Event listeners - Fixed version
      function setupEventListeners() {
        // Demo tabs
        document.querySelectorAll(".demo-tab").forEach((tab) => {
          tab.addEventListener("click", (e) => {
            e.preventDefault();
            const protocol = tab.dataset.protocol;
            if (protocol) {
              switchProtocol(protocol);
            }
          });
        });

        // Demo controls
        const connectBtn = document.getElementById("connectBtn");
        const disconnectBtn = document.getElementById("disconnectBtn");
        const clearBtn = document.getElementById("clearBtn");
        const sendBtn = document.getElementById("sendBtn");
        const messageInput = document.getElementById("messageInput");

        if (connectBtn) connectBtn.addEventListener("click", connect);
        if (disconnectBtn) disconnectBtn.addEventListener("click", disconnect);
        if (clearBtn) clearBtn.addEventListener("click", clearLogs);
        if (sendBtn) sendBtn.addEventListener("click", sendMessage);

        // Send on Enter
        if (messageInput) {
          messageInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              sendMessage();
            }
          });
        }

        // Protocol cards
        document.querySelectorAll(".protocol-card").forEach((card) => {
          card.addEventListener("click", (e) => {
            e.preventDefault();
            const protocol = card.dataset.protocol;
            if (protocol) {
              const demoSection = document.getElementById("demo");
              if (demoSection) {
                demoSection.scrollIntoView({ behavior: "smooth" });
                setTimeout(() => switchProtocol(protocol), 500);
              }
            }
          });
        });

        // Example tabs
        document.querySelectorAll(".example-tab").forEach((tab) => {
          tab.addEventListener("click", (e) => {
            e.preventDefault(); // مهم علشان يمنع الـ refresh
            const example = tab.dataset.example;
            if (example) {
              switchExample(example);
            }
          });
        });

        // Smooth scrolling for anchor links
        document.querySelectorAll('a[href^="#"]').forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            const targetId = link.getAttribute("href");
            const target = document.querySelector(targetId);
            if (target) {
              target.scrollIntoView({ behavior: "smooth" });
            }
          });
        });

        // Handle window resize
        let resizeTimeout;
        window.addEventListener("resize", () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            // Recreate particles on resize
            const particlesContainer = document.getElementById("particles");
            if (particlesContainer) {
              particlesContainer.innerHTML = "";
              createParticles();
            }
          }, 250);
        });
      }

      // Initialize - Fixed version
      function init() {
        try {
          setupNavbar();
          setupEventListeners();
          createParticles();

          // Initialize with WebSocket protocol
          switchProtocol("websocket");
          switchExample("basic");

          // Start connection time update interval
          updateInterval = setInterval(updateConnectionTime, 1000);

          log("info", "Application initialized successfully");
        } catch (error) {
          console.error("Initialization error:", error);
          log("error", `Failed to initialize: ${error.message}`);
        }
      }

      // Cleanup function
      function cleanup() {
        if (currentStream) {
          currentStream.close();
          currentStream = null;
        }

        if (updateInterval) {
          clearInterval(updateInterval);
          updateInterval = null;
        }

        startTime = null;
      }

      // Handle page visibility changes
      function handleVisibilityChange() {
        if (document.hidden) {
          // Page is hidden, reduce activity
          if (currentStream && currentStream.mockInterval) {
            clearInterval(currentStream.mockInterval);
            currentStream.mockInterval = null;
          }
        } else {
          // Page is visible, resume activity
          if (
            currentStream &&
            currentStream.isOpen &&
            !currentStream.mockInterval
          ) {
            currentStream.startMockData();
          }
        }
      }

      // Error boundary for uncaught errors
      function setupErrorHandling() {
        window.addEventListener("error", (event) => {
          console.error("Global error:", event.error);
          log(
            "error",
            `Application error: ${event.error?.message || "Unknown error"}`
          );
        });

        window.addEventListener("unhandledrejection", (event) => {
          console.error("Unhandled promise rejection:", event.reason);
          log(
            "error",
            `Promise rejection: ${event.reason?.message || "Unknown error"}`
          );
          event.preventDefault(); // Prevent default browser behavior
        });
      }

      // Performance monitoring
      function logPerformance() {
        if (window.performance && window.performance.timing) {
          const timing = window.performance.timing;
          const loadTime = timing.loadEventEnd - timing.navigationStart;
          console.log(`Page load time: ${loadTime}ms`);
        }
      }

      // Start when DOM is ready
      document.addEventListener("DOMContentLoaded", () => {
        init();
        setupErrorHandling();

        // Handle page visibility changes
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Cleanup on page unload
        window.addEventListener("beforeunload", cleanup);

        // Log performance after load
        window.addEventListener("load", () => {
          setTimeout(logPerformance, 100);
        });
      });

      // Global functions for HTML onclick handlers
      window.copyCode = copyCode;
      window.switchProtocol = switchProtocol;
      window.switchExample = switchExample;

      // Export for potential module usage
      if (typeof module !== "undefined" && module.exports) {
        module.exports = {
          MockStream,
          protocols,
          examples,
          switchProtocol,
          switchExample,
          connect,
          disconnect,
          sendMessage,
          copyCode,
          init,
          cleanup,
        };
      }
    </script>
  </body>
</html>
